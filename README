Usage:
- The Digital Twin can be configured through the configuration files.
- The Digital Twin can be deployed with the 'deploy' command.
- The Digital Twin can be destroyed with the 'destroy' command.
- With the 'info' command you can retrieve information about the Digital Twin cloud resources.

Code explanation:
- The core concept is a deployer. A deployer is responsible for managing deploy entities. A deploy entity is responsible for deploying, deleting and retrieving information from a resource entity. A resource entity could be one or more cloud resources. See example below.
- Configuration files are used to specify parameters for the deployers.
- The main function then just executes the deploy/destroy/info function of all deployers depending on user input.
- Deployer example:

Conventions:
- Every deployer should be implemented in one sperate file.
- Keep things separated, self-contained, and independent. Each deployment entity should only be aware of itself. While this is not always achievable, it should be aimed for whenever possible.
- Every Digital Twin resource name should be prefixed with the Digital Twin name. This gives all Digital Twin resources a dedicated namespace and makes them clearly distinguishable from unrelated resources in the AWS account.

Future ideas:
- Use a single provider for layer 3. Then for AWS, consider using S3 lifecycle rules to transition hot -> cold -> archive data.
- Improve the handling of constant values. This is less about the deployer itself and more about establishing a consistent approach to constants across the Digital Twin. Currently abusing a virtual IoT device seems odd.
- Possibly remove processor Lambda functions, or at least refactor them so the processor does not need to invoke the Persister directly.
- Introduce an object-oriented approach and create a class for deployers.
- Add a proper testing system or unit tests.
- Recovery mechanism for failed deployments. For example, record the point where deployment failed and allow a `deploy_continue` option to resume.
- Redeployment strategy. For example, if a config file changes, what should happen? How do we destroy the old state and fully deploy the new state?
- Group IAM role deployments to speed up deployment (reduce propagation delays). This may introduce coupling, reducing the self-contained design.


Deployer example:
# deployer file

# deploy entity 1
def deploy_resource_1():
  ...

def destroy_resource_1():
  ...

def info_resource_1():
  ...


# deploy entity 2
def deploy_resource_2():
  ...

def destroy_resource_2():
  ...

def info_resource_2():
  ...


# deployer
def deploy():
  deploy_resource_1()
  deploy_resource_2()

def destroy():
  destroy_resource_2()
  destroy_resource_1()

def info():
  info_resource_1()
  info_resource_2()


def log(string):
  print(f"Deployer Name: " + string)
